// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_backBuffer0 "v"
# define VAR_outColor0 "i"
# define VAR_waveOutPosition "m"
#endif
#else // if SHADER_MINIFIER_IMPL
// graphics_fragment_shader.i
"#version 430\n"
 "layout(binding=0) uniform sampler2D v;"
 "layout(location=0) uniform int m;"
 "vec2 f=vec2(1920,1080);"
 "float n=m/4.8e4;"
 "layout(location=0) out vec4 i;"
 "float x;"
 "int c;"
 "const float y=acos(-1.);"
 "const vec3 a=vec3(1,.5,.1),s=vec3(.8,.8,.9);"
 "vec3 t(vec3 v)"
 "{"
   "uvec3 f=floatBitsToUint(v);"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "return vec3(f)/-1u;"
 "}"
 "vec3 p(vec2 v)"
 "{"
   "vec2 f=floor(v),m=fract(v);"
   "m=m*m*(3.-2.*m);"
   "vec3 c=mix(t(vec3(f,.12)),t(vec3(f+vec2(1,0),.12)),m.x),x=mix(t(vec3(f+vec2(0,1),.12)),t(vec3(f+vec2(1),.12)),m.x);"
   "return mix(c,x,m.y);"
 "}"
 "vec3 h(vec2 v)"
 "{"
   "float m=1.;"
   "vec4 f=vec4(0);"
   "for(int c=0;c<6;c++)"
     "f+=m*vec4(p(v),1),m*=.8,v*=mat2(-1.4747,1.351,-1.351,-1.4747);"
   "return f.xyz/f.w;"
 "}"
 "float r(float v)"
 "{"
   "return v*v*(v*v)*v;"
 "}"
 "vec3 h(vec3 v,float x,float m,vec3 f,vec3 s,vec3 c)"
 "{"
   "float l=m*m;"
   "l=max(l,.001);"
   "vec3 z=.04*(1.-x)+v*x,n=normalize(f+s);"
   "float o=clamp(dot(c,s),0.,1.)+1e-5,a=clamp(dot(c,f),0.,1.),t=clamp(dot(c,n),0.,1.),d=clamp(dot(f,n),0.,1.),e=t*l,i=l/(1.-t*t+e*e),g=l*l,b=.5+2.*l*d*d;"
   "return(i*i/y*(.5/(a*sqrt(max(0.,o*o*(1.-g)+g))+o*sqrt(max(0.,a*a*(1.-g)+g))))*(z+(1.-z)*r(1.-d))+v*(1.-x)*((1.+(b-1.)*r(1.-a))*(1.+(b-1.)*r(1.-o))/y))*a;"
 "}"
 "float h(vec3 v,vec3 x)"
 "{"
   "vec3 f=abs(v)-x*.5;"
   "return min(max(f.x,max(f.y,f.z)),0.)+length(max(f,0.));"
 "}"
 "vec2 l;"
 "float d(vec3 v)"
 "{"
   "l=floor(v.xy/vec2(3,2))*vec2(3,2)+vec2(1.5,1);"
   "vec3 f=v;"
   "v.xy-=l;"
   "vec3 m=t(vec3(l,1));"
   "float a,i;"
   "vec3 z;"
   "bool n=fract(.5*l.x/3.)<.5;"
   "z=abs(fract(f*10)-.5);"
   "float s=min(dot(vec3(1),smoothstep(.02,0.,z)),1)*.001,d=v.y-clamp((v.x+1)*.5,0.,1.)*2-.5,o=min(min(max((min(abs(d),abs(d+2))-.5)*.4,-v.z),-v.z+3),max(abs(v.x)-1,-v.z+.5));"
   "o+=s;"
   "z=v-vec3(-1.35,0,-.07);"
   "z.x=abs(z.x-.1)-.1;"
   "o=min(o,length(z.xz)-.07);"
   "z.y=abs(fract(z.y)-.5)-.07;"
   "o=min(o,h(z+vec3(.1,0,0),vec3(.05,0,0))-.01);"
   "vec2 b=abs(vec2(length(z.xz),z.y))-vec2(.08,.02);"
   "o=min(o,min(max(b.x,b.y),0.)+length(max(b,0.)));"
   "float r=-v.z-.11;"
   "r=max(r,-h(v,vec3(2.8,1.8,4)));"
   "z=v;"
   "z.z-=.75;"
   "z.x=abs(abs(z.x)-.4);"
   "r=min(r,h(z,vec3(3,2,.05)));"
   "r=max(r,-h(z-vec3(.4,-.135,0),vec3(.7,1.35,.1)));"
   "r=min(r,h(v-vec3(0,-.5,.1),vec3(2.8,.6,.025))-.01);"
   "z=v-vec3(.2*clamp(round(v.x/.2),-6,6),-.5,.1);"
   "r=max(r,-h(z,vec3(.1,.5,.05)));"
   "r=min(r,h(v+vec3(0,.225,0),vec3(2.8,.05,.2))-.01);"
   "z=v-vec3(1.15,-.76,0);"
   "a=h(z,vec3(.4,.3,.15)-.02);"
   "z-=vec3(-.06,0,-.11);"
   "a=max(a,-h(z,vec3(0,0,.1))+.1);"
   "z.z-=.05;"
   "z.y-=.01*clamp(round(z.y/.01),-9,9);"
   "a=min(a,h(z,vec3(.2,0,0))-.002);"
   "r=min(r,a);"
   "float e=n?"
     "o:"
     "r,g=smoothstep(0.,2.,1.-v.y);"
   "vec3 p=v;"
   "p.x*=mix(1.2,1.,g);"
   "float u=x+m.x*y*2.,B=cos(p.x*25.+cos(p.x*8.))+cos(p.x*4.+u+.5*cos(u));"
   "p.z-=1.+.05*B*g;"
   "a=h(p,vec3(2.6,1.6,.01))*.5-.01;"
   "a+=float(n)*1e9;"
   "c=a<e?"
     "1:"
     "0;"
   "e=min(e,a);"
   "i=length(v-vec3(sign(m.x-.5),-.09,0))-.1;"
   "a=length(v-vec3(-1.4,-.9,2.9))-.1;"
   "a=n?"
     "a:"
     "i;"
   "c=a<e?"
     "2:"
     "c;"
   "return min(e,a);"
 "}"
 "vec2 d(vec3 v,vec3 m,out vec3 f,out vec3 z)"
 "{"
   "float a=1.,c,r=0.,o;"
   "for(int i=0;i<256;i++)"
     "{"
       "z=f=m+v*r;"
       "vec2 l=mod(f.xz,40.)-20.;"
       "f.xz=105.<=x&&x<120.?"
         "vec2((atan(l.y,l.x)+y)/y*24-x*.38,8.-length(l)):"
         "f.xz;"
       "float n=mod(atan(f.y,f.z)+floor(f.x/3.)*.1,y*2./3.)-y/3.;"
       "f.zy=120.<=x&&x<135.?"
         "vec2(cos(n),sin(n))*length(f.zy)-5.:"
         "f.zy;"
       "float s=x/.1171875/32+.125+floor(f.x/6)/4;"
       "f.y+=4.*(floor(s)-pow(1./(1.+fract(s)*8),5.))*sign(fract(-f.x/12)-.5)*float(90.<=x&&x<135.);"
       "f.z-=cos(length((floor(f.xy/vec2(3,2))+.5)*vec2(1.5,1))+x)*max(0,(x-105.)/45.);"
       "c=d(f);"
       "a=max(min(a,exp2(2+2*t(vec3(f)).x)*c/r),.15);"
       "vec2 b=floor(f.xy/vec2(3,2)+sign(v.xy))*vec2(3,2)+vec2(1.5,1),p=abs(b-f.xy)-vec2(1.5,1);"
       "p=max(p,0.)/abs(v.xy)+.001;"
       "float e=min(p.x,p.y);"
       "c=min(e,c);"
       "r+=c;"
       "o=exp(-r*.04);"
       "if(c<.001)"
         "return vec2(o,.15);"
       "if(r>30.+step(105,x)*1000)"
         "return vec2(0,a);"
     "}"
   "return vec2(o,a);"
 "}"
 "const vec3 o=normalize(vec3(1.5,1.5,-1));"
 "void main()"
 "{"
   "x=n;"
   "const vec2 m=gl_FragCoord.xy,z=f.xy,r=m/z;"
   "const vec3 p=t(vec3(m,x));"
   "vec3 e,y,b;"
   "float g=x/15;"
   "int u=int(g)%10;"
   "float B=fract(g)*step(g,10),C=u==5?"
     "(floor(B*4)+B)*.25:"
     "B;"
   "e=mix(vec3[](vec3(.2,.2,2.2),vec3(.4,.2,2),vec3(-2.2,-1,-.2),vec3(-.5,-1.8,-.5),vec3(0,0,-1.5),vec3(0,0,-3),vec3(4,0,-6),vec3(-10,0,20),vec3(0),vec3(0,0,-4))[u],vec3[](vec3(.1,.1,1.5),vec3(.35,.6,.4),vec3(-.1,-1,-.2),vec3(-2.8,-1.8,-.5),vec3(.4,-6,-1.5),vec3(0,0,-15),vec3(-4,40,-9),vec3(-10,-10,30),vec3(-50,0,0),vec3(0,0,-40))[u],C);"
   "y=normalize(mix(vec3[](vec3(.5,1.5,1),vec3(-.5,-1,-1),vec3(-1,-.1,.3),vec3(.8,.8,1),vec3(.2,.1,1),vec3(0,0,1),vec3(-.3,.5,1),vec3(-.4,.1,1),vec3(-1,.1,0),vec3(0,0,1))[u],vec3[](vec3(.1,.1,1),vec3(0,.5,-1),vec3(-1,-.1,1),vec3(.1,.8,1.5),vec3(-.2,-.1,1),vec3(0,0,1),vec3(.3,.5,1),vec3(-.1,-.1,1),vec3(-1,-.1,0),vec3(0,0,1))[u],C));"
   "const vec3 D=normalize(cross(vec3(0,1,0),y));"
   "b=normalize(mat3(D,normalize(cross(y,D)),y)*vec3((r-.5+(p.xy-.5)*.5/z)*2.*(z/min(z.x,z.y)),sqrt(3)));"
   "vec3 w,A;"
   "vec2 E=d(b,e,w,A),F=vec2(1,-1);"
   "int G=c;"
   "vec3 H=normalize(F.xyy*d(w+F.xyy*.001)+F.yyx*d(w+F.yyx*.001)+F.yxy*d(w+F.yxy*.001)+F.xxx*d(w+F.xxx*.001));"
   "c=G;"
   "vec3 I=sign(H)*abs(H);"
   "I/=dot(vec3(1),I);"
   "vec2 J=(I.x*w.zy+I.y*w.xz+I.z*w.xy)/vec2(1,4);"
   "vec3 K=w;"
   "K.xy-=l;"
   "vec3 L=t(vec3(l,1));"
   "bool M=fract(.5*l.x/3.)<.5;"
   "float N=0.;"
   "vec3 O=vec3(1);"
   "float P=.5,Q=.5;"
   "vec3 R=mix(a,s,L.z);"
   "if(c==0)"
     "{"
       "vec3 S=h(J*3),T=h(J*96);"
       "O=vec3(min(1,mix(.5,1.,S.y)*mix(.8,1.,sqrt(T.x))));"
       "P=O.x;"
       "Q=.01;"
       "H=normalize(H+(S-.5)*.1);"
     "}"
   "else if(c==1)"
     "O=vec3[](vec3(.8,.7,.6),vec3(.8,.2,.2),vec3(.5,.7,.8))[int(L.x*3.)],P=.99,Q=.01;"
   "else"
     " N=1.,O=R*2.;"
   "const vec3 S=H*.001*2.;"
   "w+=S;"
   "A+=S;"
   "vec3 T,U;"
   "vec2 V=d(o,A,T,U);"
   "vec3 W=vec3(0);"
   "P=105.<x&&x<=135.?"
     ".99:"
     "P;"
   "W+=V.y*h(O,Q,P,o,-b,H)*s;"
   "vec3 X=(M?"
     "vec3(-1.4,-.9,2.9):"
     "vec3(sign(L.x-.5),-.06,0))-K;"
   "float Y=length(X);"
   "W+=R*pow(1./(1.+max(0.,Y-1.)),2.)*h(O,Q,P,X/Y,-b,H);"
   "W*=sqrt(clamp(d(w+H*.1)/.1,0.,1.));"
   "W=mix(W,O,N);"
   "vec3 Z=s*mix(.01,.3,clamp(b.y*.5+.25,0.,1.)),_=max(vec3(0),mix(Z,W,E.x));"
   "_*=smoothstep(.8,.4,length(r-.5));"
   "_=mix(_,textureLod(v,r,2.).xyz,.2);"
   "_=_*(2.51*_+.03)/(_*(2.43*_+.59)+.14);"
   "_+=p*.03;"
   "_=clamp(_,0.,1.);"
   "_=pow(_,vec3(.8));"
   "_*=min((.5-abs(B-.5))*10,1);"
   "i=vec4(_,1);"
 "}" 
#endif

