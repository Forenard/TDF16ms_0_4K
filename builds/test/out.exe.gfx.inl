// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_backBuffer0 "v"
# define VAR_backBuffer1 "m"
# define VAR_backBuffer2 "o"
# define VAR_backBuffer3 "u"
# define VAR_outColor0 "r"
# define VAR_outColor1 "y"
# define VAR_outColor2 "e"
# define VAR_outColor3 "i"
# define VAR_waveOutPosition "f"
#endif
#else // if SHADER_MINIFIER_IMPL
// graphics_fragment_shader.i
"#version 430\n"
 "layout(binding=0) uniform sampler2D v;"
 "layout(binding=1) uniform sampler2D m;"
 "layout(binding=2) uniform sampler2D o;"
 "layout(binding=3) uniform sampler2D u;"
 "layout(location=0) uniform int f;"
 "vec2 n=vec2(1920,1080);"
 "float s=f/4.8e4;"
 "layout(location=0) out vec4 r;"
 "layout(location=1) out vec4 y;"
 "layout(location=2) out vec4 e;"
 "layout(location=3) out vec4 i;"
 "float l;"
 "int c;"
 "const float x=acos(-1.),z=2.*x,d=x*(3.-sqrt(5.));"
 "mat2 t(float v)"
 "{"
   "float f=cos(v),c=sin(v);"
   "return mat2(f,-c,c,f);"
 "}"
 "vec2 p(float v)"
 "{"
   "return vec2(cos(v),sin(v));"
 "}"
 "vec2 a(vec2 v)"
 "{"
   "float f=atan(v.y,v.x)+z-x*.5+x/3.;"
   "f=mod(f,z/3.)+x*.5-x/3.;"
   "return p(f)*length(v);"
 "}"
 "mat3 h(vec3 v)"
 "{"
   "v=normalize(v);"
   "vec3 f=vec3(0,1,0),c=normalize(cross(f,v));"
   "f=normalize(cross(v,c));"
   "return mat3(c,f,v);"
 "}"
 "uvec3 M(uvec3 v)"
 "{"
   "v=v*1664525u+1013904223u;"
   "v.x+=v.y*v.z;"
   "v.y+=v.z*v.x;"
   "v.z+=v.x*v.y;"
   "v^=v>>16u;"
   "v.x+=v.y*v.z;"
   "v.y+=v.z*v.x;"
   "v.z+=v.x*v.y;"
   "return v;"
 "}"
 "vec3 b(vec3 v)"
 "{"
   "uvec3 f=M(floatBitsToUint(v));"
   "return vec3(f)/float(4294967295u);"
 "}"
 "vec3 B(vec2 v)"
 "{"
   "vec2 f=floor(v),r=fract(v);"
   "r=r*r*(3.-2.*r);"
   "vec3 c=mix(b(vec3(f,.12)),b(vec3(f+vec2(1,0),.12)),r.x),n=mix(b(vec3(f+vec2(0,1),.12)),b(vec3(f+vec2(1),.12)),r.x);"
   "return mix(c,n,r.y);"
 "}"
 "vec3 g(vec2 v)"
 "{"
   "const mat2 f=t(d)*2.;"
   "float c=1.;"
   "vec4 r=vec4(0);"
   "for(int i=0;i<6;i++)"
     "r+=c*vec4(B(v),1),c*=.5,v*=f;"
   "return r.xyz/r.w;"
 "}"
 "float C(vec2 v)"
 "{"
   "vec2 f=floor(v),c=fract(v),n,e;"
   "float y=8.;"
   "for(int r=0;r<9;r++)"
     "{"
       "vec2 m=vec2(r%3-1,r/3-1),z=b(vec3(f+m,1.98)).xy,d=m+z-c;"
       "float i=dot(d,d);"
       "if(i<y)"
         "y=i,e=d,n=m;"
     "}"
   "y=8.;"
   "for(int r=0;r<25;r++)"
     "{"
       "vec2 m=vec2(r%5-2,r/5-2),z=b(vec3(f+m,1.98)).xy,d=m+z-c;"
       "if(dot(e-d,e-d)>1e-5)"
         "y=min(y,dot(.5*(e+d),normalize(d-e)));"
     "}"
   "return y;"
 "}"
 "float D(vec2 v)"
 "{"
   "const mat2 f=t(d)*1.5;"
   "float r=1.;"
   "vec2 i=vec2(0);"
   "for(int c=0;c<3;c++)"
     "{"
       "vec2 m=v+g(v*1.5).xy;"
       "float y=C(m);"
       "y=smoothstep(.05,0.,y);"
       "i+=r*vec2(y,1);"
       "r*=.5;"
       "v*=f;"
     "}"
   "return i.x/i.y;"
 "}struct Material{int type;vec3 albedo;float metallic;float roughness;};"
 "float A(float v)"
 "{"
   "return v*v*(v*v)*v;"
 "}"
 "float A(float v,float f)"
 "{"
   "float y=f*v,c=v/(1.-f*f+y*y);"
   "return c*c*(1./x);"
 "}"
 "float A(float v,float f,float y)"
 "{"
   "float c=v*v;"
   "return.5/(y*sqrt(f*f*(1.-c)+c)+f*sqrt(y*y*(1.-c)+c));"
 "}"
 "vec3 B(vec3 v,float f)"
 "{"
   "return v+(1.-v)*A(1.-f);"
 "}"
 "float C(float v,float f)"
 "{"
   "return 1.+(v-1.)*A(1.-f);"
 "}"
 "float A(float v,float f,float c,float y)"
 "{"
   "float r=.5+2.*v*y*y;"
   "return C(c,r)*C(f,r)*(1./x);"
 "}"
 "vec3 A(Material v,vec3 f,vec3 c,vec3 y,bool m)"
 "{"
   "vec3 r=v.albedo;"
   "float x=v.metallic,n=v.roughness,i=n*n;"
   "i=max(i,.001);"
   "vec3 d=normalize(f+c);"
   "float o=abs(dot(y,c))+1e-5,e=clamp(dot(y,f),0.,1.),z=clamp(dot(f,d),0.,1.),g=A(i,clamp(dot(y,d),0.,1.)),l=A(i,o,e);"
   "vec3 s=r*(1.-x)*A(i,o,e,z);"
   "return((m?"
     "1.:"
     "g*l)*B(.04*(1.-x)+r*x,z)+s)*e;"
 "}"
 "float D(vec3 v,vec3 f)"
 "{"
   "vec3 c=abs(v)-f;"
   "return length(max(c,0.))+min(max(c.x,max(c.y,c.z)),0.);"
 "}"
 "float E(vec3 v)"
 "{"
   "float f=floor(v.z/2.)*2.;"
   "v.z=mod(v.z,2.)-1.;"
   "v.xy*=t(-z*f*.05);"
   "v.xy=a(v.xy);"
   "v.y-=4.;"
   "return D(v,vec3(1e5,.5,.5));"
 "}"
 "float F(vec3 v)"
 "{"
   "float f=floor(v.z/2.)*2.;"
   "v.z=mod(v.z,2.)-1.;"
   "v.xy*=t(-z*f*.05);"
   "v.xy=a(v.xy);"
   "v.y-=2.;"
   "return D(v,vec3(1e5,.1,.1));"
 "}"
 "void B(float v,inout float f,inout int r)"
 "{"
   "if(v<f)"
     "f=v,c=r;"
   "r++;"
 "}"
 "float G(vec3 v)"
 "{"
   "int f=0;"
   "c=-1;"
   "float y=1e3;"
   "B(E(v),y,f);"
   "B(F(v),y,f);"
   "return y;"
 "}"
 "vec3 H(vec3 v)"
 "{"
   "const vec2 f=vec2(1,-1);"
   "int m=c;"
   "vec3 y=normalize(f.xyy*G(v+f.xyy*1e-4)+f.yyx*G(v+f.yyx*1e-4)+f.yxy*G(v+f.yxy*1e-4)+f.xxx*G(v+f.xxx*1e-4));"
   "c=m;"
   "return y;"
 "}"
 "vec3 E(vec3 v,vec3 f)"
 "{"
   "vec3 y=vec3(2),c=abs((floor((v+sign(f)*y)/y)+.5)*y-v)-.5*y;"
   "c=max(c,0.);"
   "c/=abs(f);"
   "return c;"
 "}"
 "bool C(vec3 v,vec3 f,out vec3 c)"
 "{"
   "float r,y=0.;"
   "for(int i=0;i<256;i++)"
     "{"
       "c=f+v*y;"
       "r=G(c);"
       "vec3 n=E(c,v);"
       "r=min(r,n.z+2e-4);"
       "y+=r;"
       "if(y>1e3)"
         "break;"
       "if(r<2e-4)"
         "return true;"
     "}"
   "return false;"
 "}"
 "Material F(vec3 v,inout vec3 f)"
 "{"
   "Material y=Material(0,vec3(1),.5,.5);"
   "if(c==0)"
     "y.albedo=vec3(1),y.roughness=.9,y.metallic=.1;"
   "else if(c==1)"
     "y.type=1,y.albedo=vec3(1,.1,.1);"
   "return y;"
 "}"
 "vec3 B(Material v,vec3 f,vec3 y,vec3 c)"
 "{"
   "vec3 r=vec3(0);"
   "r+=A(v,normalize(vec3(-f.xy,-1)),y,c,false)*vec3(.5);"
   "return r;"
 "}"
 "vec3 D(vec3 v,vec3 f,vec3 c)"
 "{"
   "Material y=F(v,c);"
   "return y.type==1?"
     "y.albedo:"
     "B(y,v,f,c);"
 "}"
 "vec3 E(inout vec3 v,vec3 f,vec3 y)"
 "{"
   "Material c=F(v,y);"
   "if(c.type==1)"
     "return c.albedo;"
   "v+=y*2.*1e-4;"
   "vec3 r=B(c,v,f,y),i,d=reflect(-f,y),n=v;"
   "if(!C(d,n,i))"
     "return r;"
   "vec3 m=H(i);"
   "i+=m*2.*1e-4;"
   "vec3 x=D(i,-d,m);"
   "r+=x*A(c,d,f,y,true);"
   "return r;"
 "}"
 "vec3 G(vec3 v,vec3 f)"
 "{"
   "vec3 y;"
   "if(!C(v,f,y))"
     "return vec3(0);"
   "vec3 c=H(y);"
   "return E(y,-v,c);"
 "}"
 "void H(out vec2 v,out vec2 f)"
 "{"
   "vec2 c=gl_FragCoord.xy,y=n.xy;"
   "v=c/y;"
   "f=(v*2.-1.)*(y/min(y.x,y.y));"
   "l=s;"
 "}"
 "void C(out vec3 v,out vec3 f,out vec3 c,vec2 y)"
 "{"
   "v=vec3(0,0,l);"
   "c=vec3(0,0,1);"
   "mat3 r=h(c);"
   "float m=1./tan(60.*x/360.);"
   "m-=m*length(y)*0.;"
   "vec3 i,n,d,e;"
   "i=normalize(r*vec3(y,m));"
   "n=v;"
   "d=c;"
   "e+=r*vec3(y*2.5,-5);"
   "f=normalize(mix(d,i,1.));"
   "v=mix(e,n,1.);"
 "}"
 "void main()"
 "{"
   "vec2 v,y;"
   "H(v,y);"
   "vec3 f,c,d;"
   "C(f,c,d,y);"
   "vec3 i=G(c,f);"
   "i+=g(y*5.)*.3;"
   "i+=D(y)*.3;"
   "r=vec4(i,1);"
 "}" 
#endif

