// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_backBuffer0 "v"
# define VAR_outColor0 "i"
# define VAR_waveOutPosition "m"
#endif
#else // if SHADER_MINIFIER_IMPL
// graphics_fragment_shader.i
"#version 430\n"
 "layout(binding=0) uniform sampler2D v;"
 "layout(location=0) uniform int m;"
 "vec2 f=vec2(1920,1080);"
 "float n=m/4.8e4;"
 "layout(location=0) out vec4 i;"
 "float y;"
 "int c;"
 "const float x=acos(-1.),s=x*2.,z=x*(3.-sqrt(5.));"
 "const vec3 a=vec3(255,137,14)/255.,p=vec3(191,211,255)/255.;"
 "vec2 t(float v)"
 "{"
   "return vec2(cos(v),sin(v));"
 "}"
 "mat2 e(float v)"
 "{"
   "vec2 m=t(v);"
   "return mat2(m.x,m.y,-m.y,m.x);"
 "}"
 "vec3 d(vec3 v)"
 "{"
   "uvec3 f=floatBitsToUint(v);"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "return vec3(f)/float(-1u);"
 "}"
 "vec3 h(vec2 v)"
 "{"
   "vec2 m=floor(v),f=fract(v);"
   "f=f*f*(3.-2.*f);"
   "vec3 c=mix(d(vec3(m,.12)),d(vec3(m+vec2(1,0),.12)),f.x),y=mix(d(vec3(m+vec2(0,1),.12)),d(vec3(m+vec2(1),.12)),f.x);"
   "return mix(c,y,f.y);"
 "}"
 "vec3 r(vec2 v)"
 "{"
   "const mat2 m=e(z)*2.;"
   "float f=1.;"
   "vec4 c=vec4(0);"
   "for(int i=0;i<6;i++)"
     "c+=f*vec4(h(v),1),f*=.5,v*=m;"
   "return c.xyz/c.w;"
 "}"
 "float w(float v)"
 "{"
   "return v*v*(v*v)*v;"
 "}"
 "vec3 d(vec3 v,float y,float m,vec3 f,vec3 z,vec3 c)"
 "{"
   "float l=m*m;"
   "l=max(l,.001);"
   "vec3 i=.04*(1.-y)+v*y,p=normalize(f+z);"
   "float s=clamp(dot(c,z),0.,1.)+1e-5,a=clamp(dot(c,f),0.,1.),n=clamp(dot(c,p),0.,1.),u=clamp(dot(f,p),0.,1.),o=n*l,d=l/(1.-n*n+o*o),g=l*l,r=.5+2.*l*u*u;"
   "return(d*d/x*(.5/(a*sqrt(max(0.,s*s*(1.-g)+g))+s*sqrt(max(0.,a*a*(1.-g)+g))))*(i+(1.-i)*w(1.-u))+v*(1.-y)*((1.+(r-1.)*w(1.-a))*(1.+(r-1.)*w(1.-s))/x))*a;"
 "}"
 "float d(vec3 v,vec3 x)"
 "{"
   "vec3 m=abs(v)-x*.5;"
   "return min(max(m.x,max(m.y,m.z)),0.)+length(max(m,0.));"
 "}"
 "vec2 l;"
 "float u(vec3 v)"
 "{"
   "vec3 m=v;"
   "l=floor(v.xy/vec2(3,2))*vec2(3,2)+vec2(1.5,1);"
   "v.xy-=l;"
   "vec3 f=d(vec3(l,0));"
   "float i,p;"
   "vec3 z;"
   "bool a=fract(.5*l.x/3.)<.5;"
   "z=abs(fract(m*10)-.5);"
   "float n=dot(vec3(2),smoothstep(.05,.025,z))/3*.001,g=v.y-clamp((v.x+1)*.5,0.,1.)*2-.5,r=min(min(max((min(abs(g),abs(g+2))-.5)*.4,-v.z),-v.z+3),max(abs(v.x)-1,-v.z+.5));"
   "r+=n;"
   "z=v-vec3(-1.35,0,-.07);"
   "z.x=abs(z.x-.1)-.1;"
   "r=min(r,length(z.xz)-.07);"
   "z.y=abs(fract(z.y)-.5)-.07;"
   "r=min(r,d(z+vec3(.1,0,0),vec3(.05,0,0))-.01);"
   "vec2 o=abs(vec2(length(z.xz),z.y))-vec2(.08,.02);"
   "r=min(r,min(max(o.x,o.y),0.)+length(max(o,0.)));"
   "float u=-v.z-.11;"
   "u=max(u,-d(v,vec3(2.8,1.8,4)));"
   "z=v;"
   "z.z-=.75;"
   "z.x=abs(abs(z.x)-.4);"
   "u=min(u,d(z,vec3(3,2,.05)));"
   "u=max(u,-d(z-vec3(.4,-.135,0),vec3(.7,1.35,.1)));"
   "u=min(u,d(v-vec3(0,-.5,.1),vec3(2.8,.6,.025))-.01);"
   "z=v-vec3(.2*clamp(round(v.x/.2),-6,6),-.5,.1);"
   "u=max(u,-d(z,vec3(.1,.5,.05)));"
   "u=min(u,d(v+vec3(0,.225,0),vec3(2.8,.05,.2))-.01);"
   "z=v-vec3(1.15,-.76,0);"
   "i=d(z,vec3(.4,.3,.15)-.02);"
   "z-=vec3(-.06,0,-.11);"
   "i=max(i,-d(z,vec3(0,0,.1))+.1);"
   "z.z-=.05;"
   "z.y-=.01*clamp(round(z.y/.01),-9,9);"
   "i=min(i,d(z,vec3(.2,0,0))-.002);"
   "u=min(u,i);"
   "float b=a?"
     "r:"
     "u,w=smoothstep(0.,2.,1.-v.y);"
   "vec3 e=v;"
   "e.x*=mix(1.2,1.,w);"
   "float h=y+f.x*s,t=cos(e.x*x*8.+cos(e.x*8.))*.05+sin(e.x*4.+h+.5*cos(h))*.05;"
   "e.z-=1.+t*w;"
   "i=d(e,vec3(2.6,1.6,.01))*.5-.01;"
   "i+=float(a)*1e9;"
   "c=i<b?"
     "1:"
     "0;"
   "b=min(b,i);"
   "p=length(v-vec3(sign(f.x-.5),-.09,0))-.1;"
   "i=length(v-vec3(-1.4,-.9,2.9))-.1;"
   "i=a?"
     "i:"
     "p;"
   "c=i<b?"
     "2:"
     "c;"
   "return min(b,i);"
 "}"
 "vec2 d(vec3 v,vec3 m,out vec3 f)"
 "{"
   "float z=1.,i=1e2,c,r=0.;"
   "for(int l=0;l<256;l++)"
     "{"
       "f=m+v*r;"
       "f.z=90.<=y&&y<105.?"
         "abs(f.z)-2.:"
         "f.z;"
       "f.xz=105.<=y&&y<120.?"
         "vec2((atan(f.z,f.x)+x)/s*24,length(f.xz)-4.):"
         "f.xz;"
       "c=u(f);"
       "float a=c*c/(2.*i),p=sqrt(c*c-a*a);"
       "z=min(z,p/(.01*max(0.,r-a)));"
       "i=c;"
       "vec2 d=floor(f.xy/vec2(3,2)+sign(v.xy))*vec2(3,2)+vec2(1.5,1),o=abs(d-f.xy)-vec2(1.5,1);"
       "o=max(o,0.)/abs(v.xy)+.001+float(f.z<-2.)*1e2;"
       "c=min(c,min(o.x,o.y));"
       "r+=c;"
       "if(c<.001)"
         "return vec2(1,.01);"
       "if(r>1e2)"
         "return vec2(0,max(z,.01));"
     "}"
   "return vec2(0,max(z,.01));"
 "}"
 "const vec3 o=normalize(vec3(1,1.5,-1));"
 "void main()"
 "{"
   "y=n;"
   "const vec2 m=gl_FragCoord.xy,z=f.xy,g=m/z;"
   "const vec3 s=d(vec3(m,y));"
   "vec3 b=vec3(1),e=vec3(0,0,-1),w;"
   "float h=y/15.;"
   "int t=int(h)%8;"
   "float B=fract(h),C=t==4?"
     "(floor(B*4.)+B)*.25:"
     "B;"
   "b=mix(vec3[](vec3(.2,.2,2.2),vec3(.4,.2,2),vec3(-2.2,-1,0),vec3(-.5,-1.8,-.3),vec3(0,0,-3),vec3(0,0,-6),vec3(0),vec3(0))[t],vec3[](vec3(.1,.1,1.5),vec3(.35,.6,.4),vec3(-.1,-1,0),vec3(-2.8,-1.8,-.3),vec3(0,0,-15),vec3(0,30,-9),vec3(-70,0,0),vec3(0,70,0))[t],C);"
   "e=normalize(mix(vec3[](vec3(.5,1.5,1),vec3(-.5,-1,-1),vec3(-1,-.1,.3),vec3(1,.2,.8),vec3(0,0,1),vec3(-.2,0,1),vec3(-1,.2,0),vec3(1,1,0))[t],vec3[](vec3(.1,.1,1),vec3(0,0,-1),vec3(-1,-.1,1),vec3(1,.2,.8),vec3(0,0,1),vec3(.2,0,1),vec3(-1,-.2,0),vec3(0,1,.1))[t],C));"
   "const vec3 A=normalize(cross(vec3(0,1,0),e));"
   "w=normalize(mat3(A,normalize(cross(e,A)),e)*vec3((g-.5+(s.xy-.5)*.25/z)*2.*(z/min(z.x,z.y)),1./tan(75.*x/360.)));"
   "vec3 D;"
   "vec2 E=d(w,b,D),F=vec2(1,-1);"
   "int G=c;"
   "vec3 H=normalize(F.xyy*u(D+F.xyy*.001)+F.yyx*u(D+F.yyx*.001)+F.yxy*u(D+F.yxy*.001)+F.xxx*u(D+F.xxx*.001));"
   "c=G;"
   "vec3 I=sign(H)*abs(H);"
   "I/=dot(vec3(1),I);"
   "vec2 J=(I.x*D.zy+I.y*D.xz+I.z*D.xy)*vec2(3,1);"
   "vec3 K=D;"
   "K.xy-=l;"
   "vec3 L=d(vec3(l,0));"
   "bool M=fract(.5*l.x/3.)<.5;"
   "float N=0.;"
   "vec3 O=vec3(1);"
   "float P=.5,Q=.5;"
   "vec3 R=mix(a,p,L.x);"
   "if(c==0)"
     "{"
       "vec3 S=r(J*3.),T=r(J*96.);"
       "O=vec3(clamp(1.3*mix(.6,1.,S.y)*mix(.8,1.,pow(T.x,3.)),0.,1.));"
       "P=mix(.5,1.,pow(S.y,3.));"
       "Q=.01;"
       "H=normalize(H+(S*2.-1.)*.05);"
     "}"
   "else if(c==1)"
     "O=vec3[](vec3(.8,.7,.6),vec3(.8,.2,.2),vec3(.5,.7,.8))[int(L.x*3.)],P=.99,Q=.01;"
   "else"
     " N=1.,O=R;"
   "D+=H*.001*1.5;"
   "vec3 S;"
   "vec2 T=d(o,D,S);"
   "vec3 U=vec3(0);"
   "U+=T.y*d(O,Q,P,o,-w,H)*p*.5;"
   "vec3 V=(M?"
     "vec3(-1.4,-.9,2.9):"
     "vec3(sign(L.x-.5),-.06,0))-K;"
   "float W=length(V);"
   "U+=R*pow(1./(1.+max(0.,W-1.)),2.)*d(O,Q,P,V/W,-w,H);"
   "U*=sqrt(clamp(u(D+H*.05)/.05,0.,1.));"
   "U=mix(U,O,N);"
   "vec3 X=vec3(mix(.01,.3,clamp((w.y+.5)*.5,0.,1.)))*smoothstep(1.,.9,w.y),Y=mix(X,U,E.x);"
   "Y+=s*.03;"
   "Y=pow(Y,vec3(.6));"
   "Y=Y*(2.51*Y+.03)/(Y*(2.43*Y+.59)+.14);"
   "Y.xy=smoothstep(0.,1.,Y.xy);"
   "Y*=clamp((.5-abs(B-.5))*10.,0.,1.);"
   "vec4 Z=vec4(Y,1);"
   "i=mix(Z,texture(v,g),.5);"
 "}" 
#endif

