// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_backBuffer0 "v"
# define VAR_backBuffer1 "m"
# define VAR_backBuffer2 "y"
# define VAR_backBuffer3 "o"
# define VAR_outColor0 "r"
# define VAR_outColor1 "u"
# define VAR_outColor2 "e"
# define VAR_outColor3 "z"
# define VAR_waveOutPosition "s"
#endif
#else // if SHADER_MINIFIER_IMPL
// graphics_fragment_shader.i
"#version 430\n"
 "layout(binding=0) uniform sampler2D v;"
 "layout(binding=1) uniform sampler2D m;"
 "layout(binding=2) uniform sampler2D y;"
 "layout(binding=3) uniform sampler2D o;"
 "layout(location=0) uniform int s;"
 "vec2 n=vec2(1920,1080);"
 "float f=s/4.8e4;"
 "layout(location=0) out vec4 r;"
 "layout(location=1) out vec4 u;"
 "layout(location=2) out vec4 e;"
 "layout(location=3) out vec4 z;"
 "float i;"
 "int l;"
 "const float x=acos(-1.),g=2.*x,c=x*(3.-sqrt(5.));"
 "mat2 t(float v)"
 "{"
   "float f=cos(v),n=sin(v);"
   "return mat2(f,-n,n,f);"
 "}"
 "vec2 t(vec3 v,vec3 f)"
 "{"
   "f=sign(f)*pow(abs(f),vec3(1));"
   "f/=dot(vec3(1),f);"
   "return f.x*v.zy+f.y*v.xz+f.z*v.xy;"
 "}"
 "mat3 p(vec3 v)"
 "{"
   "v=normalize(v);"
   "vec3 f=vec3(0,1,0),i=normalize(cross(f,v));"
   "f=normalize(cross(v,i));"
   "return mat3(i,f,v);"
 "}"
 "uvec3 a(uvec3 v)"
 "{"
   "v=v*1664525u+1013904223u;"
   "v.x+=v.y*v.z;"
   "v.y+=v.z*v.x;"
   "v.z+=v.x*v.y;"
   "v^=v>>16u;"
   "v.x+=v.y*v.z;"
   "v.y+=v.z*v.x;"
   "v.z+=v.x*v.y;"
   "return v;"
 "}"
 "vec3 d(vec3 v)"
 "{"
   "uvec3 f=a(floatBitsToUint(v));"
   "return vec3(f)/float(4294967295u);"
 "}"
 "vec3 b(vec2 v)"
 "{"
   "vec2 f=floor(v),r=fract(v);"
   "r=r*r*(3.-2.*r);"
   "vec3 i=mix(d(vec3(f,.12)),d(vec3(f+vec2(1,0),.12)),r.x),n=mix(d(vec3(f+vec2(0,1),.12)),d(vec3(f+vec2(1),.12)),r.x);"
   "return mix(i,n,r.y);"
 "}"
 "vec3 w(vec2 v)"
 "{"
   "const mat2 f=t(c)*2.;"
   "float n=1.;"
   "vec4 r=vec4(0);"
   "for(int i=0;i<6;i++)"
     "r+=n*vec4(b(v),1),n*=.5,v*=f;"
   "return r.xyz/r.w;"
 "}"
 "float M(vec2 v)"
 "{"
   "vec2 f=floor(v),n=fract(v),i,y;"
   "float r=8.;"
   "for(int l=0;l<9;l++)"
     "{"
       "vec2 m=vec2(l%3-1,l/3-1),e=d(vec3(f+m,1.98)).xy,c=m+e-n;"
       "float s=dot(c,c);"
       "if(s<r)"
         "r=s,y=c,i=m;"
     "}"
   "r=8.;"
   "for(int l=0;l<25;l++)"
     "{"
       "vec2 m=vec2(l%5-2,l/5-2),e=d(vec3(f+m,1.98)).xy,c=m+e-n;"
       "if(dot(y-c,y-c)>1e-5)"
         "r=min(r,dot(.5*(y+c),normalize(c-y)));"
     "}"
   "return r;"
 "}"
 "float h(vec2 v)"
 "{"
   "const mat2 m=t(c)*1.5;"
   "float f=1.;"
   "vec2 r=vec2(0);"
   "for(int l=0;l<3;l++)"
     "{"
       "vec2 i=v+w(v*1.5).xy;"
       "float n=M(i);"
       "n=smoothstep(.02,0.,n);"
       "r+=f*vec2(n,1);"
       "f*=.5;"
       "v*=m;"
     "}"
   "return 1.-r.x/r.y;"
 "}"
 "vec3 B(vec3 v)"
 "{"
   "const mat3 f=p(vec3(1,2,3));"
   "vec4 r=vec4(0);"
   "for(int l=0;l<8;l++)"
     "v+=sin(v.yzx),r+=vec4(cross(cos(v),sin(v.zxy)),1),v*=f*1.5;"
   "return r.xyz/r.w;"
 "}struct Material{int type;vec3 albedo;float metallic;float roughness;};"
 "float C(float v)"
 "{"
   "return v*v*(v*v)*v;"
 "}"
 "float B(float v,float f)"
 "{"
   "float r=f*v,n=v/(1.-f*f+r*r);"
   "return n*n*(1./x);"
 "}"
 "float B(float v,float f,float r)"
 "{"
   "float n=v*v;"
   "return.5/(r*sqrt(f*f*(1.-n)+n)+f*sqrt(r*r*(1.-n)+n));"
 "}"
 "vec3 C(vec3 v,float f)"
 "{"
   "return v+(1.-v)*C(1.-f);"
 "}"
 "float M(float v,float f)"
 "{"
   "return 1.+(v-1.)*C(1.-f);"
 "}"
 "float B(float v,float f,float i,float r)"
 "{"
   "float n=.5+2.*v*r*r;"
   "return M(i,n)*M(f,n)*(1./x);"
 "}"
 "vec3 B(Material v,vec3 f,vec3 n,vec3 i,bool r)"
 "{"
   "vec3 m=v.albedo;"
   "float c=v.metallic,y=v.roughness,l=y*y;"
   "l=max(l,.001);"
   "vec3 o=normalize(f+n);"
   "float s=abs(dot(i,n))+1e-5,x=clamp(dot(i,f),0.,1.),e=clamp(dot(f,o),0.,1.),g=B(l,clamp(dot(i,o),0.,1.)),D=B(l,s,x);"
   "vec3 u=m*(1.-c)*B(l,s,x,e);"
   "return((r?"
     "1.:"
     "g*D)*C(.04*(1.-c)+m*c,e)+u)*x;"
 "}"
 "float A(vec3 v)"
 "{"
   "const vec3 f=vec3(2,1,4);"
   "v.xy=mod(v.xy,f.xy)-.5*f.xy;"
   "return-v.z;"
 "}"
 "void A(float v,inout float f,inout int r)"
 "{"
   "if(v<f)"
     "f=v,l=r;"
   "r++;"
 "}"
 "float D(vec3 v)"
 "{"
   "int f=0;"
   "l=-1;"
   "float n=1e3;"
   "A(A(v),n,f);"
   "return n;"
 "}"
 "vec3 E(vec3 v)"
 "{"
   "const vec2 f=vec2(1,-1);"
   "int m=l;"
   "vec3 r=normalize(f.xyy*D(v+f.xyy*1e-4)+f.yyx*D(v+f.yyx*1e-4)+f.yxy*D(v+f.yxy*1e-4)+f.xxx*D(v+f.xxx*1e-4));"
   "l=m;"
   "return r;"
 "}"
 "vec3 A(vec3 v,vec3 f)"
 "{"
   "vec3 r=vec3(2),i=abs((floor((v+sign(f)*r)/r)+.5)*r-v)-.5*r;"
   "i=max(i,0.);"
   "i/=abs(f);"
   "return i;"
 "}"
 "bool C(vec3 v,vec3 f,out vec3 i)"
 "{"
   "float r,l=0.;"
   "for(int n=0;n<256;n++)"
     "{"
       "i=f+v*l;"
       "r=D(i);"
       "vec3 m=A(i,v);"
       "r=min(r,m.z+.001);"
       "l+=r;"
       "if(l>1e3)"
         "break;"
       "if(r<.001)"
         "return true;"
     "}"
   "return false;"
 "}"
 "Material D(vec3 v,inout vec3 f)"
 "{"
   "Material r=Material(0,vec3(1),.5,.5);"
   "vec2 i=t(v,f);"
   "vec3 n=w(i*3.*vec2(3,1)),l=w(i*36.);"
   "float m=h(i*2.),y=mix(.6,1.,pow(n.y,1.))*mix(.75,1.,pow(l.x,3.))*pow(m,.5);"
   "vec2 o=abs(fract(i+(l.yz-.5)*.01)-.5);"
   "float c=(1.-smoothstep(.4975,.495,o.x)*smoothstep(.4975,.495,o.y))*l.y;"
   "c=mix(1.,.2,c);"
   "y*=c;"
   "float e=smoothstep(.3,.6,B(v*3.).z);"
   "y*=mix(1.,.7,e);"
   "r.albedo=vec3(1)*y;"
   "r.roughness=.9;"
   "r.metallic=.1;"
   "return r;"
 "}"
 "Material E(vec3 v,inout vec3 f)"
 "{"
   "Material r=Material(0,vec3(1),.5,.5);"
   "if(l==0)"
     "r=D(v,f);"
   "return r;"
 "}"
 "vec3 A(Material v,vec3 f,vec3 i,vec3 n)"
 "{"
   "vec3 r=vec3(0);"
   "r+=B(v,normalize(vec3(-1,1,-1)),i,n,false)*vec3(1);"
   "return r;"
 "}"
 "vec3 D(vec3 v,vec3 f,vec3 n)"
 "{"
   "Material r=E(v,n);"
   "return r.type==1?"
     "r.albedo:"
     "A(r,v,f,n);"
 "}"
 "vec3 E(inout vec3 v,vec3 f,vec3 n)"
 "{"
   "Material r=E(v,n);"
   "if(r.type==1)"
     "return r.albedo;"
   "v+=n*.001;"
   "vec3 l=A(r,v,f,n),i,c=reflect(-f,n),y=v;"
   "if(!C(c,y,i))"
     "return l;"
   "vec3 m=E(i);"
   "i+=m*.001;"
   "vec3 s=D(i,-c,m);"
   "l+=s*B(r,c,f,n,true);"
   "return l;"
 "}"
 "vec3 a(vec3 v,vec3 f)"
 "{"
   "vec3 i;"
   "if(!C(v,f,i))"
     "return vec3(0);"
   "vec3 n=E(i);"
   "return E(i,-v,n);"
 "}"
 "void b(out vec2 v,out vec2 r)"
 "{"
   "vec2 m=gl_FragCoord.xy,l=n.xy;"
   "v=m/l;"
   "r=(v*2.-1.)*(l/min(l.x,l.y));"
   "i=f;"
 "}"
 "void C(out vec3 v,out vec3 f,out vec3 r,vec2 n)"
 "{"
   "float m=mod(i,6.);"
   "r=m<3.?"
     "(v=vec3(0,i,-5),normalize(vec3(-.5,.5,1))):"
     "(v=vec3(0,0,-2),normalize(vec3(-.5,.5,1)));"
   "mat3 l=p(r);"
   "float c=1./tan(60.*x/360.);"
   "c-=c*length(n)*0.;"
   "vec3 y,e,o,d;"
   "y=normalize(l*vec3(n,c));"
   "e=v;"
   "o=r;"
   "d+=l*vec3(n*2.5,-5);"
   "f=normalize(mix(o,y,1.));"
   "v=mix(d,e,1.);"
 "}"
 "void main()"
 "{"
   "vec2 v,n;"
   "b(v,n);"
   "vec3 f,i,y;"
   "C(f,i,y,n);"
   "vec3 l=a(i,f);"
   "l=l;"
   "l=l;"
   "r=vec4(l,1);"
 "}" 
#endif

