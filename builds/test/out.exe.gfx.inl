// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_backBuffer0 "v"
# define VAR_outColor0 "c"
# define VAR_waveOutPosition "m"
#endif
#else // if SHADER_MINIFIER_IMPL
// graphics_fragment_shader.i
"#version 430\n"
 "layout(binding=0) uniform sampler2D v;"
 "layout(location=0) uniform int m;"
 "vec2 a=vec2(1920,1080);"
 "float f=m/4.8e4;"
 "layout(location=0) out vec4 c;"
 "float x;"
 "int i;"
 "const float y=acos(-1.),s=y*2.,z=y*(3.-sqrt(5.));"
 "const vec3 d=vec3(255,137,14)/255.,l=vec3(191,211,255)/255.;"
 "vec2 n(float v)"
 "{"
   "return vec2(cos(v),sin(v));"
 "}"
 "mat2 t(float v)"
 "{"
   "vec2 u=n(v);"
   "return mat2(u.x,u.y,-u.y,u.x);"
 "}"
 "vec3 p(vec3 v)"
 "{"
   "uvec3 u=floatBitsToUint(v);"
   "u=(u>>8U^u.yzx)*1103515245u;"
   "u=(u>>8U^u.yzx)*1103515245u;"
   "u=(u>>8U^u.yzx)*1103515245u;"
   "return vec3(u)/float(-1u);"
 "}"
 "vec3 h(vec2 v)"
 "{"
   "vec2 u=floor(v),y=fract(v);"
   "y=y*y*(3.-2.*y);"
   "vec3 m=mix(p(vec3(u,.12)),p(vec3(u+vec2(1,0),.12)),y.x),x=mix(p(vec3(u+vec2(0,1),.12)),p(vec3(u+vec2(1),.12)),y.x);"
   "return mix(m,x,y.y);"
 "}"
 "vec3 e(vec2 v)"
 "{"
   "const mat2 m=t(z)*2.;"
   "float y=1.;"
   "vec4 u=vec4(0);"
   "for(int f=0;f<6;f++)"
     "u+=y*vec4(h(v),1),y*=.5,v*=m;"
   "return u.xyz/u.w;"
 "}"
 "float r(float v)"
 "{"
   "return v*v*(v*v)*v;"
 "}"
 "vec3 e(vec3 v,float u,float m,vec3 x,vec3 z,vec3 f)"
 "{"
   "float c=m*m;"
   "c=max(c,.001);"
   "vec3 i=.04*(1.-u)+v*u,l=normalize(x+z);"
   "float s=clamp(dot(f,z),0.,1.)+1e-5,a=clamp(dot(f,x),0.,1.),n=clamp(dot(f,l),0.,1.),p=clamp(dot(x,l),0.,1.),b=n*c,d=c/(1.-n*n+b*b),o=c*c,e=.5+2.*c*p*p;"
   "return(d*d/y*(.5/(a*sqrt(max(0.,s*s*(1.-o)+o))+s*sqrt(max(0.,a*a*(1.-o)+o))))*(i+(1.-i)*r(1.-p))+v*(1.-u)*((1.+(e-1.)*r(1.-a))*(1.+(e-1.)*r(1.-s))/y))*a;"
 "}"
 "float e(vec3 v,vec3 y)"
 "{"
   "vec3 u=abs(v)-y*.5;"
   "return min(max(u.x,max(u.y,u.z)),0.)+length(max(u,0.));"
 "}"
 "const vec2 u=vec2(3,2);"
 "vec2 w(inout vec3 v)"
 "{"
   "vec2 m=floor(v.xy/u)*u+u*.5;"
   "v.xy=mod(v.xy,u)-.5*u;"
   "return m;"
 "}"
 "float b(vec3 v)"
 "{"
   "vec3 m=v;"
   "vec2 f=w(v);"
   "vec3 c=p(vec3(f,0));"
   "float z,l;"
   "vec3 a;"
   "bool d=fract(.5*f.x/u.x)<.5;"
   "a=abs(fract(m*10)-.5);"
   "float o=dot(vec3(2),smoothstep(.05,.025,a))/3*.001,b=v.y-clamp((v.x+1)*.5,0.,1.)*2-.5,r=min(min(max((min(abs(b),abs(b+2))-.5)*.4,-v.z),-v.z+3),max(abs(v.x)-1,-v.z+.5));"
   "r+=o;"
   "a=v-vec3(-u.x*.45,0,-.07);"
   "a.x=abs(a.x-.1)-.1;"
   "r=min(r,length(a.xz)-.07);"
   "a.y=abs(fract(a.y)-.5)-.06;"
   "r=min(r,e(a+vec3(.1,0,0),vec3(.05,0,0))-.01);"
   "vec2 h=abs(vec2(length(a.xz),a.y))-vec2(.08,.02);"
   "r=min(r,min(max(h.x,h.y),0.)+length(max(h,0.)));"
   "float g=-v.z;"
   "g=max(g,-e(v,vec3(u-.2,4)));"
   "a=v-vec3(0,0,.75);"
   "a.x=abs(a.x);"
   "g=min(g,e(a,vec3(u-.2,.05)));"
   "const vec3 t=vec3((u-.2).x*.25-.125,(u-.2).y*.75,.1);"
   "g=max(g,-e(a-vec3(t.x*.5+.05,-t.y*.1,0),t));"
   "const vec3 B=vec3(t.x,t.y*.5,t.z);"
   "g=max(g,-e(a-vec3(B.x*1.5+.15,B.y*.3,0),B));"
   "g=min(g,-.01+e(v-vec3(0,-u.y*.25,.1),vec3(u.x-.2,u.y*.3,.025)));"
   "a=v-vec3(0,-u.y*.25,.1);"
   "a.x=a.x-.2*clamp(round(a.x/.2),-6,6);"
   "g=max(g,-e(a,vec3(.06,u.y*.25,.05)));"
   "g=min(g,-.01+e(v-vec3(0,-u.y*.1-.025,0),vec3(u.x-.2,.05,.2)));"
   "z=-.01+e(v-vec3(1.1,-.77,-.02),vec3(.4,.28,.1));"
   "a=v-vec3(1.1,-.77,-.02)-vec3(-.06,0,-.1);"
   "z=max(z,-e(a,vec3(0,0,.1))+.1);"
   "a.z-=.05;"
   "z=min(z,length(a)-.015);"
   "const float C=y/32.;"
   "float A=atan(a.y,a.x);"
   "A=mod(A,C*2.)-C;"
   "a.xy=n(A)*length(a.xy);"
   "z=min(z,e(a,vec3(.2,0,0))-.002);"
   "g=min(g,z);"
   "float D=d?"
     "r:"
     "g,E=smoothstep(0.,1.5,.9-v.y);"
   "vec3 F=v;"
   "F.x*=mix(1.1,1.,E);"
   "float G=c.x*s,H=x*.5+G,I=cos(G+F.x*y*7.+.5*y*cos(F.x*7.))*.05+cos(F.x*2.+H*2.+.5*y*cos(H))*.05;"
   "F-=vec3(0,0,1.+I*E);"
   "z=e(F,vec3(u-.4,.01))*.5-.01;"
   "z+=float(d)*1e9;"
   "i=z<D?"
     "1:"
     "0;"
   "D=min(D,z);"
   "l=length(v-vec3(sign(c.x-.5),-.09,0))-.1;"
   "z=length(v-vec3(-u*.5+.1,2.9))-.1;"
   "z=d?"
     "z:"
     "l;"
   "i=z<D?"
     "2:"
     "i;"
   "return min(D,z);"
 "}"
 "vec2 b(vec3 v,vec3 m,out vec3 a)"
 "{"
   "float f=1.,z=1e2,c,g=0.;"
   "for(int i=0;i<256;i++)"
     "{"
       "a=m+v*g;"
       "a.z=90.<=x&&x<105.?"
         "abs(a.z)-2.:"
         "a.z;"
       "a.xz=105.<=x&&x<120.?"
         "vec2((atan(a.z,a.x)+y)/s*u.x*8.,length(a.xz)-4.):"
         "a.xz;"
       "c=b(a);"
       "float o=c*c/(2.*z),l=sqrt(c*c-o*o);"
       "f=min(f,l/(.02*max(0.,g-o)));"
       "z=c;"
       "vec2 d=(floor((a.xy+sign(v.xy)*u)/u)+.5)*u,r=abs(d-a.xy)-.5*u;"
       "r=max(r,0.)/abs(v.xy)+.001+float(a.z<-2.)*1e2;"
       "c=min(c,min(r.x,r.y));"
       "g+=c;"
       "if(c<.001)"
         "return vec2(1,.05);"
       "if(g>1e2)"
         "return vec2(0,max(f,.05));"
     "}"
   "return vec2(0,max(f,.05));"
 "}"
 "const vec3 o=normalize(vec3(1,1,-1));"
 "void main()"
 "{"
   "x=f;"
   "const vec2 m=gl_FragCoord.xy,z=a.xy,g=m/z;"
   "const vec3 n=p(vec3(m,x));"
   "vec3 r=vec3(1),s=vec3(0,0,-1),t;"
   "float h=x/15.;"
   "int D=int(h)%8;"
   "float F=fract(h),E=D==4?"
     "(floor(F*4.)+F)*.25:"
     "F;"
   "r=mix(vec3[](vec3(.2,.2,2.2),vec3(.4,.2,2),vec3(.8-u.x,-1,0),vec3(-.5,-1.8,-.3),vec3(0,0,-3),vec3(0,0,-6),vec3(0),vec3(0))[D],vec3[](vec3(.1,.1,1.5),vec3(.35,.6,.4),vec3(-.1,-1,0),vec3(.2-u.x,-1.8,-.3),vec3(0,0,-15),vec3(0,30,-9),vec3(-70,0,0),vec3(0,70,0))[D],E);"
   "s=normalize(mix(vec3[](vec3(.5,1.5,1),vec3(-.5,-1,-1),vec3(-1,-.1,.3),vec3(1,.2,.8),vec3(0,0,1),vec3(-.2,0,1),vec3(-1,.2,0),vec3(1,1,0))[D],vec3[](vec3(.1,.1,1),vec3(0,0,-1),vec3(-1,-.1,1),vec3(1,.2,.8),vec3(0,0,1),vec3(.2,0,1),vec3(-1,-.2,0),vec3(0,1,.1))[D],E));"
   "const vec3 A=normalize(cross(vec3(0,1,0),s));"
   "t=normalize(mat3(A,normalize(cross(s,A)),s)*vec3((g-.5+(n.xy-.5)*.25/z)*2.*(z/min(z.x,z.y)),1./tan(75.*y/360.)));"
   "vec3 B;"
   "vec2 C=b(t,r,B),H=vec2(1,-1);"
   "int G=i;"
   "vec3 I=normalize(H.xyy*b(B+H.xyy*.001)+H.yyx*b(B+H.yyx*.001)+H.yxy*b(B+H.yxy*.001)+H.xxx*b(B+H.xxx*.001));"
   "i=G;"
   "vec3 J=sign(I)*abs(I);"
   "J/=dot(vec3(1),J);"
   "vec2 K=(J.x*B.zy+J.y*B.xz+J.z*B.xy)*vec2(3,1);"
   "vec3 L=B;"
   "vec2 M=w(L);"
   "vec3 N=p(vec3(M,0));"
   "float O=0.;"
   "vec3 P=vec3(1);"
   "float Q=.5,R=.5;"
   "vec3 S=mix(d,l,N.x);"
   "if(i==0)"
     "{"
       "vec3 T=e(K*3.),U=e(K*96.);"
       "P=vec3(clamp(1.3*mix(.6,1.,T.y)*mix(.8,1.,pow(U.x,3.)),0.,1.));"
       "Q=mix(.5,1.,pow(T.y,3.));"
       "R=.01;"
       "I=normalize(I+(T*2.-1.)*.05);"
     "}"
   "else if(i==1)"
     "P=vec3[](vec3(.8,.7,.6),vec3(.8,.2,.2),vec3(.5,.7,.8))[int(N.x*3.)],Q=.99,R=.01;"
   "else"
     " O=1.,P=S;"
   "B+=I*.001*2.;"
   "vec3 T;"
   "vec2 U=b(o,B,T);"
   "vec3 V=vec3(0);"
   "V+=U.y*e(P,R,Q,o,-t,I)*l*.5;"
   "vec3 W=(fract(.5*M.x/u.x)<.5?"
     "vec3(-u*.5+.1,2.9):"
     "vec3(sign(N.x-.5),-.06,0))-L;"
   "float X=length(W);"
   "V+=S*pow(1./(1.+max(0.,X-1.)),2.)*e(P,R,Q,W/X,-t,I);"
   "V*=sqrt(clamp(b(B+I*.05)/.05,0.,1.));"
   "V=mix(V,P,O);"
   "vec3 Y=vec3(mix(.01,.3,clamp((t.y+.5)*.5,0.,1.)))*smoothstep(1.,.9,t.y),Z=mix(Y,V,C.x);"
   "Z+=n*.03;"
   "Z=pow(Z,vec3(.6));"
   "Z=Z*(2.51*Z+.03)/(Z*(2.43*Z+.59)+.14);"
   "Z.xy=smoothstep(0.,1.,Z.xy);"
   "Z*=clamp((.5-abs(F-.5))*10.,0.,1.);"
   "vec4 _=vec4(Z,1);"
   "c=mix(_,texture(v,g),.5);"
 "}" 
#endif

