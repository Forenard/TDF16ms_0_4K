// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_backBuffer0 "v"
# define VAR_outColor0 "f"
# define VAR_waveOutPosition "m"
#endif
#else // if SHADER_MINIFIER_IMPL
// graphics_fragment_shader.i
"#version 430\n"
 "layout(binding=0) uniform sampler2D v;"
 "layout(location=0) uniform int m;"
 "vec2 n=vec2(1920,1080);"
 "float a=m/4.8e4;"
 "layout(location=0) out vec4 f;"
 "float x;"
 "int c;"
 "const float y=acos(-1.),s=y*2.,z=y*(3.-sqrt(5.));"
 "const vec3 i=vec3(255,137,14)/255.,p=vec3(191,211,255)/255.;"
 "vec2 t(float v)"
 "{"
   "return vec2(cos(v),sin(v));"
 "}"
 "mat2 e(float v)"
 "{"
   "vec2 m=t(v);"
   "return mat2(m.x,m.y,-m.y,m.x);"
 "}"
 "vec3 d(vec3 v)"
 "{"
   "uvec3 f=floatBitsToUint(v);"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "return vec3(f)/float(-1u);"
 "}"
 "vec3 h(vec2 v)"
 "{"
   "vec2 m=floor(v),f=fract(v);"
   "f=f*f*(3.-2.*f);"
   "vec3 c=mix(d(vec3(m,.12)),d(vec3(m+vec2(1,0),.12)),f.x),x=mix(d(vec3(m+vec2(0,1),.12)),d(vec3(m+vec2(1),.12)),f.x);"
   "return mix(c,x,f.y);"
 "}"
 "vec3 r(vec2 v)"
 "{"
   "const mat2 m=e(z)*2.;"
   "float f=1.;"
   "vec4 l=vec4(0);"
   "for(int c=0;c<6;c++)"
     "l+=f*vec4(h(v),1),f*=.5,v*=m;"
   "return l.xyz/l.w;"
 "}"
 "float w(float v)"
 "{"
   "return v*v*(v*v)*v;"
 "}"
 "vec3 d(vec3 v,float x,float m,vec3 f,vec3 l,vec3 c)"
 "{"
   "float a=m*m;"
   "a=max(a,.001);"
   "vec3 z=.04*(1.-x)+v*x,p=normalize(f+l);"
   "float s=clamp(dot(c,l),0.,1.)+1e-5,d=clamp(dot(c,f),0.,1.),n=clamp(dot(c,p),0.,1.),b=clamp(dot(f,p),0.,1.),o=n*a,i=a/(1.-n*n+o*o),g=a*a,r=.5+2.*a*b*b;"
   "return(i*i/y*(.5/(d*sqrt(max(0.,s*s*(1.-g)+g))+s*sqrt(max(0.,d*d*(1.-g)+g))))*(z+(1.-z)*w(1.-b))+v*(1.-x)*((1.+(r-1.)*w(1.-d))*(1.+(r-1.)*w(1.-s))/y))*d;"
 "}"
 "float d(vec3 v,vec3 x)"
 "{"
   "vec3 m=abs(v)-x*.5;"
   "return min(max(m.x,max(m.y,m.z)),0.)+length(max(m,0.));"
 "}"
 "const vec2 l=vec2(3,2);"
 "vec2 u(inout vec3 v)"
 "{"
   "vec2 m=floor(v.xy/l)*l+l*.5;"
   "v.xy=mod(v.xy,l)-.5*l;"
   "return m;"
 "}"
 "float b(vec3 v)"
 "{"
   "vec3 m=v;"
   "vec2 f=u(v);"
   "vec3 a=d(vec3(f,0));"
   "float z,r;"
   "vec3 i;"
   "bool n=fract(.5*f.x/l.x)<.5;"
   "i=abs(fract(m*10)-.5);"
   "float b=dot(vec3(2),smoothstep(.05,.025,i))/3*.001,p=v.y-clamp((v.x+1)*.5,0.,1.)*2-.5,o=min(min(max((min(abs(p),abs(p+2))-.5)*.4,-v.z),-v.z+3),max(abs(v.x)-1,-v.z+.5));"
   "o+=b;"
   "i=v-vec3(-1.35,0,-.07);"
   "i.x=abs(i.x-.1)-.1;"
   "o=min(o,length(i.xz)-.07);"
   "i.y=abs(fract(i.y)-.5)-.07;"
   "o=min(o,d(i+vec3(.1,0,0),vec3(.05,0,0))-.01);"
   "vec2 g=abs(vec2(length(i.xz),i.y))-vec2(.08,.02);"
   "o=min(o,min(max(g.x,g.y),0.)+length(max(g,0.)));"
   "float e=-v.z-.11;"
   "e=max(e,-d(v,vec3(2.8,1.8,4)));"
   "i=v;"
   "i.z-=.75;"
   "i.x=abs(abs(i.x)-.4);"
   "e=min(e,d(i,vec3(3,2,.05)));"
   "e=max(e,-d(i-vec3(.4,-.135,0),vec3(.7,1.35,.1)));"
   "e=min(e,d(v-vec3(0,-.5,.1),vec3(2.8,.6,.025))-.01);"
   "i=v-vec3(.2*clamp(round(v.x/.2),-6,6),-.5,.1);"
   "e=max(e,-d(i,vec3(.1,.5,.05)));"
   "e=min(e,d(v+vec3(0,.225,0),vec3(2.8,.05,.2))-.01);"
   "i=v-vec3(1.15,-.76,0);"
   "z=d(i,vec3(.4,.3,.15)-.02);"
   "i-=vec3(-.06,0,-.11);"
   "z=max(z,-d(i,vec3(0,0,.1))+.1);"
   "i.z-=.05;"
   "i.y-=.01*clamp(round(i.y/.01),-9,9);"
   "z=min(z,d(i,vec3(.2,0,0))-.002);"
   "e=min(e,z);"
   "float h=n?"
     "o:"
     "e,w=smoothstep(0.,1.5,.9-v.y);"
   "vec3 t=v;"
   "t.x*=mix(1.1,1.,w);"
   "float B=a.x*s,C=x*.5+B,A=cos(B+t.x*y*7.+.5*y*cos(t.x*7.))*.05+cos(t.x*2.+C*2.+.5*y*cos(C))*.05;"
   "t-=vec3(0,0,1.+A*w);"
   "z=d(t,vec3(l-.4,.01))*.5-.01;"
   "z+=float(n)*1e9;"
   "c=z<h?"
     "1:"
     "0;"
   "h=min(h,z);"
   "r=length(v-vec3(sign(a.x-.5),-.09,0))-.1;"
   "z=length(v-vec3(-l*.5+.1,2.9))-.1;"
   "z=n?"
     "z:"
     "r;"
   "c=z<h?"
     "2:"
     "c;"
   "return min(h,z);"
 "}"
 "vec2 b(vec3 v,vec3 m,out vec3 f)"
 "{"
   "float i=1.,z=1e2,c,e=0.;"
   "for(int o=0;o<256;o++)"
     "{"
       "f=m+v*e;"
       "f.z=90.<=x&&x<105.?"
         "abs(f.z)-2.:"
         "f.z;"
       "f.xz=105.<=x&&x<120.?"
         "vec2((atan(f.z,f.x)+y)/s*l.x*8.,length(f.xz)-4.):"
         "f.xz;"
       "c=b(f);"
       "float a=c*c/(2.*z),p=sqrt(c*c-a*a);"
       "i=min(i,p/(.02*max(0.,e-a)));"
       "z=c;"
       "vec2 d=(floor((f.xy+sign(v.xy)*l)/l)+.5)*l,r=abs(d-f.xy)-.5*l;"
       "r=max(r,0.)/abs(v.xy)+.001+float(f.z<-2.)*1e2;"
       "c=min(c,min(r.x,r.y));"
       "e+=c;"
       "if(c<.001)"
         "return vec2(1,.05);"
       "if(e>1e2)"
         "return vec2(0,max(i,.05));"
     "}"
   "return vec2(0,max(i,.05));"
 "}"
 "const vec3 o=normalize(vec3(1,1,-1));"
 "void main()"
 "{"
   "x=a;"
   "x=46.5;"
   "const vec2 m=gl_FragCoord.xy,z=n.xy,e=m/z;"
   "const vec3 s=d(vec3(m,x));"
   "vec3 g=vec3(1),h=vec3(0,0,-1),t;"
   "float w=x/15.;"
   "int B=int(w)%8;"
   "float C=fract(w),A=B==4?"
     "(floor(C*4.)+C)*.25:"
     "C;"
   "g=mix(vec3[](vec3(.2,.2,2.2),vec3(.4,.2,2),vec3(.8-l.x,-1,0),vec3(-.5,-1.8,-.3),vec3(0,0,-3),vec3(0,0,-6),vec3(0),vec3(0))[B],vec3[](vec3(.1,.1,1.5),vec3(.35,.6,.4),vec3(-.1,-1,0),vec3(.2-l.x,-1.8,-.3),vec3(0,0,-15),vec3(0,30,-9),vec3(-70,0,0),vec3(0,70,0))[B],A);"
   "h=normalize(mix(vec3[](vec3(.5,1.5,1),vec3(-.5,-1,-1),vec3(-1,-.1,.3),vec3(1,.2,.8),vec3(0,0,1),vec3(-.2,0,1),vec3(-1,.2,0),vec3(1,1,0))[B],vec3[](vec3(.1,.1,1),vec3(0,0,-1),vec3(-1,-.1,1),vec3(1,.2,.8),vec3(0,0,1),vec3(.2,0,1),vec3(-1,-.2,0),vec3(0,1,.1))[B],A));"
   "const vec3 D=normalize(cross(vec3(0,1,0),h));"
   "t=normalize(mat3(D,normalize(cross(h,D)),h)*vec3((e-.5+(s.xy-.5)*.25/z)*2.*(z/min(z.x,z.y)),1./tan(75.*y/360.)));"
   "vec3 E;"
   "vec2 F=b(t,g,E),G=vec2(1,-1);"
   "int H=c;"
   "vec3 I=normalize(G.xyy*b(E+G.xyy*.001)+G.yyx*b(E+G.yyx*.001)+G.yxy*b(E+G.yxy*.001)+G.xxx*b(E+G.xxx*.001));"
   "c=H;"
   "vec3 J=sign(I)*abs(I);"
   "J/=dot(vec3(1),J);"
   "vec2 K=(J.x*E.zy+J.y*E.xz+J.z*E.xy)*vec2(3,1);"
   "vec3 L=E;"
   "vec2 M=u(L);"
   "vec3 N=d(vec3(M,0));"
   "float O=0.;"
   "vec3 P=vec3(1);"
   "float Q=.5,R=.5;"
   "vec3 S=mix(i,p,N.x);"
   "if(c==0)"
     "{"
       "vec3 T=r(K*3.),U=r(K*96.);"
       "P=vec3(clamp(1.3*mix(.6,1.,T.y)*mix(.8,1.,pow(U.x,3.)),0.,1.));"
       "Q=mix(.5,1.,pow(T.y,3.));"
       "R=.01;"
       "I=normalize(I+(T*2.-1.)*.05);"
     "}"
   "else if(c==1)"
     "P=vec3[](vec3(.8,.7,.6),vec3(.8,.2,.2),vec3(.5,.7,.8))[int(N.x*3.)],Q=.99,R=.01;"
   "else"
     " O=1.,P=S;"
   "E+=I*.001*1.5;"
   "vec3 T;"
   "vec2 U=b(o,E,T);"
   "vec3 V=vec3(0);"
   "V+=U.y*d(P,R,Q,o,-t,I)*p*.5;"
   "vec3 W=(fract(.5*M.x/l.x)<.5?"
     "vec3(-l*.5+.1,2.9):"
     "vec3(sign(N.x-.5),-.06,0))-L;"
   "float X=length(W);"
   "V+=S*pow(1./(1.+max(0.,X-1.)),2.)*d(P,R,Q,W/X,-t,I);"
   "V*=sqrt(clamp(b(E+I*.05)/.05,0.,1.));"
   "V=mix(V,P,O);"
   "vec3 Y=vec3(mix(.01,.3,clamp((t.y+.5)*.5,0.,1.)))*smoothstep(1.,.9,t.y),Z=mix(Y,V,F.x);"
   "Z+=s*.03;"
   "Z=pow(Z,vec3(.6));"
   "Z=Z*(2.51*Z+.03)/(Z*(2.43*Z+.59)+.14);"
   "Z.xy=smoothstep(0.,1.,Z.xy);"
   "Z*=clamp((.5-abs(C-.5))*10.,0.,1.);"
   "vec4 _=vec4(Z,1);"
   "f=mix(_,texture(v,e),.5);"
 "}" 
#endif

