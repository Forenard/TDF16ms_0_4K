// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADER_MINIFIER_IMPL
#ifndef SHADER_MINIFIER_HEADER
# define SHADER_MINIFIER_HEADER
# define VAR_backBuffer0 "v"
# define VAR_outColor0 "i"
# define VAR_waveOutPosition "m"
#endif
#else // if SHADER_MINIFIER_IMPL
// graphics_fragment_shader.i
"#version 430\n"
 "layout(binding=0) uniform sampler2D v;"
 "layout(location=0) uniform int m;"
 "vec2 f=vec2(1920,1080);"
 "float n=m/4.8e4;"
 "layout(location=0) out vec4 i;"
 "float y;"
 "int c;"
 "const float x=acos(-1.);"
 "const vec3 d=vec3(1,.5,.1),s=vec3(.8,.8,.9);"
 "vec3 t(vec3 v)"
 "{"
   "uvec3 f=floatBitsToUint(v);"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "f=(f>>8U^f.yzx)*1103515245u;"
   "return vec3(f)/float(-1u);"
 "}"
 "vec3 p(vec2 v)"
 "{"
   "vec2 f=floor(v),m=fract(v);"
   "m=m*m*(3.-2.*m);"
   "vec3 c=mix(t(vec3(f,.12)),t(vec3(f+vec2(1,0),.12)),m.x),x=mix(t(vec3(f+vec2(0,1),.12)),t(vec3(f+vec2(1),.12)),m.x);"
   "return mix(c,x,m.y);"
 "}"
 "vec3 h(vec2 v)"
 "{"
   "float m=1.;"
   "vec4 f=vec4(0);"
   "for(int c=0;c<6;c++)"
     "f+=m*vec4(p(v),1),m*=.5,v*=mat2(-1.4747,1.351,-1.351,-1.4747);"
   "return f.xyz/f.w;"
 "}"
 "float r(float v)"
 "{"
   "return v*v*(v*v)*v;"
 "}"
 "vec3 h(vec3 v,float y,float m,vec3 f,vec3 z,vec3 c)"
 "{"
   "float a=m*m;"
   "a=max(a,.001);"
   "vec3 d=.04*(1.-y)+v*y,l=normalize(f+z);"
   "float s=clamp(dot(c,z),0.,1.)+1e-5,e=clamp(dot(c,f),0.,1.),n=clamp(dot(c,l),0.,1.),u=clamp(dot(f,l),0.,1.),t=n*a,i=a/(1.-n*n+t*t),o=a*a,p=.5+2.*a*u*u;"
   "return(i*i/x*(.5/(e*sqrt(max(0.,s*s*(1.-o)+o))+s*sqrt(max(0.,e*e*(1.-o)+o))))*(d+(1.-d)*r(1.-u))+v*(1.-y)*((1.+(p-1.)*r(1.-e))*(1.+(p-1.)*r(1.-s))/x))*e;"
 "}"
 "float h(vec3 v,vec3 y)"
 "{"
   "vec3 f=abs(v)-y*.5;"
   "return min(max(f.x,max(f.y,f.z)),0.)+length(max(f,0.));"
 "}"
 "vec2 a;"
 "float e(vec3 v)"
 "{"
   "a=floor(v.xy/vec2(3,2))*vec2(3,2)+vec2(1.5,1);"
   "vec3 f=v;"
   "v.xy-=a;"
   "vec3 m=t(vec3(a,1));"
   "float l,i;"
   "vec3 z;"
   "bool n=fract(.5*a.x/3.)<.5;"
   "z=abs(fract(f*10)-.5);"
   "float s=min(dot(vec3(1),smoothstep(.02,0.,z)),1)*.001,d=v.y-clamp((v.x+1)*.5,0.,1.)*2-.5,r=min(min(max((min(abs(d),abs(d+2))-.5)*.4,-v.z),-v.z+3),max(abs(v.x)-1,-v.z+.5));"
   "r+=s;"
   "z=v-vec3(-1.35,0,-.07);"
   "z.x=abs(z.x-.1)-.1;"
   "r=min(r,length(z.xz)-.07);"
   "z.y=abs(fract(z.y)-.5)-.07;"
   "r=min(r,h(z+vec3(.1,0,0),vec3(.05,0,0))-.01);"
   "vec2 p=abs(vec2(length(z.xz),z.y))-vec2(.08,.02);"
   "r=min(r,min(max(p.x,p.y),0.)+length(max(p,0.)));"
   "float e=-v.z-.11;"
   "e=max(e,-h(v,vec3(2.8,1.8,4)));"
   "z=v;"
   "z.z-=.75;"
   "z.x=abs(abs(z.x)-.4);"
   "e=min(e,h(z,vec3(3,2,.05)));"
   "e=max(e,-h(z-vec3(.4,-.135,0),vec3(.7,1.35,.1)));"
   "e=min(e,h(v-vec3(0,-.5,.1),vec3(2.8,.6,.025))-.01);"
   "z=v-vec3(.2*clamp(round(v.x/.2),-6,6),-.5,.1);"
   "e=max(e,-h(z,vec3(.1,.5,.05)));"
   "e=min(e,h(v+vec3(0,.225,0),vec3(2.8,.05,.2))-.01);"
   "z=v-vec3(1.15,-.76,0);"
   "l=h(z,vec3(.4,.3,.15)-.02);"
   "z-=vec3(-.06,0,-.11);"
   "l=max(l,-h(z,vec3(0,0,.1))+.1);"
   "z.z-=.05;"
   "z.y-=.01*clamp(round(z.y/.01),-9,9);"
   "l=min(l,h(z,vec3(.2,0,0))-.002);"
   "e=min(e,l);"
   "float b=n?"
     "r:"
     "e,u=smoothstep(0.,2.,1.-v.y);"
   "vec3 o=v;"
   "o.x*=mix(1.2,1.,u);"
   "float g=y+m.x*x*2.,B=cos(o.x*25.+cos(o.x*8.))+cos(o.x*4.+g+.5*cos(g));"
   "o.z-=1.+.05*B*u;"
   "l=h(o,vec3(2.6,1.6,.01))*.5-.01;"
   "l+=float(n)*1e9;"
   "c=l<b?"
     "1:"
     "0;"
   "b=min(b,l);"
   "i=length(v-vec3(sign(m.x-.5),-.09,0))-.1;"
   "l=length(v-vec3(-1.4,-.9,2.9))-.1;"
   "l=n?"
     "l:"
     "i;"
   "c=l<b?"
     "2:"
     "c;"
   "return min(b,l);"
 "}"
 "vec2 e(vec3 v,vec3 m,out vec3 f,out vec3 z)"
 "{"
   "float l=1.,c,r=0.;"
   "for(int i=0;i<256;i++)"
     "{"
       "z=f=m+v*r;"
       "f.z=90.<=y&&y<105.?"
         "abs(f.z)-2.:"
         "f.z;"
       "f.xz=105.<=y&&y<120.?"
         "vec2((atan(f.z,f.x)+x)/x*24,length(f.xz)-8.):"
         "f.xz;"
       "float d=y/.1171875/32+.125+floor(f.x/6)/4;"
       "f.y+=4.*(floor(d)-pow(1./(1.+fract(d)*8),5.))*sign(fract(f.x/12)-.5)*float(90.<=y&&y<120.);"
       "f.z+=cos(length(floor(f.xy/vec2(3,2))+vec2(1.5,1))+y)*max(0,(y-90.)/45.);"
       "c=e(f);"
       "l=max(min(l,256*c/r),.05);"
       "vec2 a=floor(f.xy/vec2(3,2)+sign(v.xy))*vec2(3,2)+vec2(1.5,1),o=abs(a-f.xy)-vec2(1.5,1);"
       "o=max(o,0.)/abs(v.xy)+.001+step(f.z,-30)*1e2;"
       "float p=min(o.x,o.y);"
       "c=min(p,c);"
       "r+=c;"
       "if(c<.001)"
         "return vec2(1,.05);"
       "if(r>1e2)"
         "return vec2(0,l);"
     "}"
   "return vec2(1,l);"
 "}"
 "const vec3 l=normalize(vec3(1.5,1.5,-1));"
 "void main()"
 "{"
   "y=n;"
   "const vec2 m=gl_FragCoord.xy,z=f.xy,o=m/z;"
   "const vec3 p=t(vec3(m,y));"
   "vec3 r,b,u;"
   "float g=y/15.;"
   "int B=int(g)%9;"
   "float w=fract(g)*step(g,9),C=B==4?"
     "(floor(w*4.)+w)*.25:"
     "w;"
   "r=mix(vec3[](vec3(.2,.2,2.2),vec3(.4,.2,2),vec3(-2.2,-1,-.2),vec3(-.5,-1.8,-.3),vec3(0,0,-3),vec3(0,0,-6),vec3(0),vec3(0),vec3(0,0,-4))[B],vec3[](vec3(.1,.1,1.5),vec3(.35,.6,.4),vec3(-.1,-1,-.2),vec3(-2.8,-1.8,-.3),vec3(0,0,-15),vec3(0,40,-9),vec3(-70,0,0),vec3(0,70,0),vec3(0,0,-25))[B],C);"
   "b=normalize(mix(vec3[](vec3(.5,1.5,1),vec3(-.5,-1,-1),vec3(-1,-.1,.3),vec3(.8,.8,1),vec3(0,0,1),vec3(-.2,.5,1),vec3(-1,.2,0),vec3(1,1,0),vec3(0,0,1))[B],vec3[](vec3(.1,.1,1),vec3(0,.5,-1),vec3(-1,-.1,1),vec3(.1,.8,1.5),vec3(0,0,1),vec3(.2,.5,1),vec3(-1,-.2,0),vec3(0,1,.1),vec3(0,0,1))[B],C));"
   "const vec3 A=normalize(cross(vec3(0,1,0),b));"
   "u=normalize(mat3(A,normalize(cross(b,A)),b)*vec3((o-.5+(p.xy-.5)*.25/z)*2.*(z/min(z.x,z.y)),1./tan(70.*x/360.)));"
   "vec3 D,E;"
   "vec2 F=e(u,r,D,E),G=vec2(1,-1);"
   "int H=c;"
   "vec3 I=normalize(G.xyy*e(D+G.xyy*.001)+G.yyx*e(D+G.yyx*.001)+G.yxy*e(D+G.yxy*.001)+G.xxx*e(D+G.xxx*.001));"
   "c=H;"
   "vec3 J=sign(I)*abs(I);"
   "J/=dot(vec3(1),J);"
   "vec2 K=(J.x*D.zy+J.y*D.xz+J.z*D.xy)*vec2(3,1);"
   "vec3 L=D;"
   "L.xy-=a;"
   "vec3 M=t(vec3(a,1));"
   "bool N=fract(.5*a.x/3.)<.5;"
   "float O=0.;"
   "vec3 P=vec3(1);"
   "float Q=.5,R=.5;"
   "vec3 S=mix(d,s,M.z);"
   "if(c==0)"
     "{"
       "vec3 T=h(K*3.),U=h(K*96.);"
       "P=vec3(min(1,mix(.5,1.,T.y)*mix(.9,1.,pow(U.x,3.))));"
       "Q=P.x;"
       "R=.01;"
       "I=normalize(I+(T-.5)*.1);"
     "}"
   "else if(c==1)"
     "P=vec3[](vec3(.8,.7,.6),vec3(.8,.2,.2),vec3(.5,.7,.8))[int(M.x*3.)],Q=.99,R=.01;"
   "else"
     " O=1.,P=S;"
   "const vec3 T=I*.001*2.;"
   "D+=T;"
   "E+=T;"
   "vec3 U,V;"
   "vec2 W=e(l,E,U,V);"
   "vec3 X=vec3(0);"
   "X+=W.y*h(P,R,Q,l,-u,I)*s;"
   "vec3 Y=(N?"
     "vec3(-1.4,-.9,2.9):"
     "vec3(sign(M.x-.5),-.06,0))-L;"
   "float Z=length(Y);"
   "X+=S*pow(1./(1.+max(0.,Z-1.)),2.)*h(P,R,Q,Y/Z,-u,I);"
   "X*=sqrt(clamp(e(D+I*.05)/.05,0.,1.));"
   "X=mix(X,P,O);"
   "vec3 _=vec3(mix(.01,.3,clamp((u.y+.5)*.5,0.,1.)))*smoothstep(1.,.9,u.y),j=mix(_,X,F.x);"
   "j+=p*.03;"
   "j=pow(j,vec3(.8));"
   "j=j*(2.51*j+.03)/(j*(2.43*j+.59)+.14);"
   "j*=min((.5-abs(w-.5))*10,1);"
   "vec4 k=vec4(j,1);"
   "i=mix(k,textureLod(v,o,2.),.5);"
 "}" 
#endif

